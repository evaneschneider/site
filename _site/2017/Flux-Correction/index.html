<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title> - Flux Correction</title>
  <link rel="shortcut icon" href="http://evaneschneider.github.io/site/assets/images/favicon.ico">
  <link rel="stylesheet" href="http://evaneschneider.github.io/site/assets/css/style.css">
  <link rel="alternate" type="application/rss+xml" title="My Blog" href="http://evaneschneider.github.io/site/rss.xml">
  <link rel="stylesheet" href="http://evaneschneider.github.io/site/assets/css/highlight.css">
</head>
<body>

  <nav class="main-nav">
    
        <a href="http://evaneschneider.github.io/site/"> <span class="arrow">←</span> Home </a>
    

    
        
            <a href="http://evaneschneider.github.io/site/about">About </a>
        
    
    <a class="cta" href="http://evaneschneider.github.io/site/feed.xml">Subscribe</a>
</nav>

  

  <section id="wrapper" class="">
    <article class="post">
    <header>
        <h1>Flux Correction</h1>
        <h2 class="headline">June 20, 2017</h2>
    </header>
    <section id="post-body">
        <p>This post is dedicated to describing the simple but effective first-order flux correction I mentioned in my last post. When using one of Cholla’s unsplit integrators (CTU or Van Leer), simulations that involve extreme temperature/density contrasts and/or high mach numbers have a tendency to cause the code to crash. Typically, these sorts of crashes start when the high-order flux update of the conserved variables yields a negative pressure. These pressure errors then propagate, eventully leading to negative densities or total energies (or NANs) that cause the code to crash. In a previous effort to solve this problem, I introduced a dual-energy update in Cholla, described in a series of posts starting <a href="http://localhost:40002015/dual-energy-1/">here</a>, that allows the code to separately track and update the internal energy of the cells, and uses this non-conservative energy estimate if the total energy yields a negative pressure. While the dual-energy update did help, it was not able to completely solve the problem.</p>

<p>The first order flux update is a simple fix that aims to decrease the likelihood of causing a cell’s energy or density to become negative as a result of fluxes that are too large. Because Cholla uses monotonic reconstruction methods, a 1D update should never cause such a problem. However, in a multidimensional update, the fluxes calculated for one direction don’t need to obey monotonicity with the other directions. As a result, the combined fluxes from multiple dimensions <em>can</em> result in too much density or energy being taken out of a cell when running 2D or 3D problems. The idea behind the first-order flux udpate is to assume that such a situation is much less likely when using fluxes calculated using first-order spatial reconstruction (rather than PPM, which is what I typically use).</p>

<p>I’ve implemented the correction with the Van Leer integrator. Cholla’s Van Leer integrator is a predictor-corrector method, described in Stone &amp; Gardiner (2009). The first step uses first-order (PCM) reconstruction followed by a Riemann solve to generate an initial set of fluxes. These fluxes are then used to update the conserved variables in the cells by a half step (the prediction). The half-step values of the conserved variables are then used in a third-order spatial reconstruction to generate input states for a second set of Riemann problems. The “corrected” fluxes generated by the second Riemann solve are used to update the <em>original</em> values of the conserved variables by a full time step. This method is considered “unsplit”, because the second set of input states generated knows something about the fluxes coming from the other directions, and all three directions are updated every time step.</p>

<p>The only differenece when the first-order flux correction is applied is that first-order reconstruction is used to generate the second set of input states. This correction is applied if a cell has a negative pressure or density after the higher-order update. Because Cholla calculates all the cell updates simultaneously on the GPU, the first-order flux update does not translate well to a multi-threaded algorithm. Instead, my approach was to create two conserved variable buffers on the CPU. At each timestep, the variables from the first buffer are sent over to the GPU and updated (as before). They are then copied back into the second buffer on the CPU, and every cell is checked for negative density/pressure. If a cell is flagged, the first-order correction is applied. Once all values in the second buffer have been corrected, I switch the pointers on the buffers and go to the next timestep.</p>

<p>On its own, the first-order flux correction was not able to keep the code from crashing - I still generated negative total energies. However, when combined with the dual-energy update, is has proven quite robust. I’ve only tried it with adiabatic simulations thus far, but they cover 5 - 6 orders of magnitude in density and temperature, and it completely eliminates negative pressures. I will update this post with the results when cooling is turned on (typically a more challenging problem since internal energy is behing removed from cells).</p>

    </section>
</article>
<footer id="post-meta" class="clearfix">
    <a href="http://twitter.com/navelation">
        <img class="avatar" src="http://evaneschneider.github.io/site/assets/images/avatar.png">
        <div>
            <span class="dark">Evan Schneider</span>
            <span>Blogging about stuff</span>
        </div>
    </a>

    <section id="sharing">
        <a class="twitter" href="https://twitter.com/intent/tweet?text=/2017/Flux-Correction/ - Flux Correction by @navelation"><span class="icon-twitter"> Tweet</span></a>

<a class="facebook" href="#" onclick="
    window.open(
      'https://www.facebook.com/sharer/sharer.php?u='+encodeURIComponent(location.href),
      'facebook-share-dialog',
      'width=626,height=436');
    return false;"><span class="icon-facebook-rect"> Share</span>
</a>
    </section>
</footer>

<!-- Disqus comments -->


<!-- Archive post list -->




  </section>

  <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
  <script src="http://evaneschneider.github.io/site/assets/js/main.js"></script>
  <script src="http://evaneschneider.github.io/site/assets/js/highlight.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>

  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-XXXXXXXX-X', 'auto');
    ga('send', 'pageview');
  </script>
  <!-- Include mathjax support -->
  <script type="text/javascript"
    src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>

</body>
</html>



